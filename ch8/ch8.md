# 进程控制

## 进程标识

* 对于每个进程来说是唯一的
* 一个进程终止后，**使用延迟复用算法，赋予新建进程的ID不同于最近终止进程的ID**
* 一些专用进程
  * 0号进程：调度进程（交换进程，是内核中的系统进程）
  * 1号进程：init（普通进程，用户级，有超级用户特权）

## fork

* fork返回给父进程自身的的pid的理由：父进程可以有多个子进程，但没有获取他们ID的函数
* 子进程获得父进程数据空间、堆和栈的副本（**注意是副本，他们并不共享这些部分**）
  * 由于fork后多跟exec，所以现在大多使用**写时复制（copy-on-write）**：需要执行的区域父进程和子进程共享，**且内核将其转为只读**，如果要修改这些区域，则内核为修改区域的内存制作一个副本（通常是一页）
* **fork与标准IO**
  * 在fork前若使用标准IO库写入文件（全缓冲）
    * fork时，数据仍在缓冲区中
    * fork后，数据被带入子程序的缓冲区
    * 此时父子进程各有一个该内容的缓冲区
    * 在exit时会将他们写入文件
* **文件共享**
  * 所有父进程打开文件描述符都被复制到子进程中（像是执行dup函数）
  * **并且他们共享文件偏移量**
* fork和exit
  * 如果父进程在子进程之前exit，则子进程们变成init的子进程
  * 子进程exit后没被父进程回收资源的变成僵尸zombie进程 



## exec函数

* 调用exec函数之后，进程执行的程序完全替换为新程序，并从main开始执行
* **exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段**
* 新程序继承了调用进程的ID、父进程ID等、控制终端、当前工作目录、根目录、nice值



## 解释器文件

